#line 2 "console.cpp.in"
#include "console.h"
#include <libguile.h>

/*
 * 	NOTE: the cpp file is autogenerated from the cpp.in file!
 */

#include <libcgl/texture.h>
#include <libcgl/shader.h>
#include <libcgl/prepared.h>

#include "stock-shader.h"
#include "interaction.h"

#include <stdlib.h>
#include <string.h>
#include <string>
#include <iostream>
#include <list>
#include <vector>

#include "cgls-config.h"

#if LIBCGLS_HAVE_LIBCAIRO == 1
#include <cairo/cairo.h>
static cairo_t* create_cairo_context(int width, int height, int channels, cairo_surface_t** surf, unsigned char** buffer);
#endif


using namespace std;


struct console {
	char *name;
	texture_ref tex;
	int screen_w, screen_h;
	int height;
	shader_ref shader;
	mesh_ref mesh;
#if LIBCGLS_HAVE_LIBCAIRO == 1
	cairo_t *cairo;
	cairo_surface_t *cairo_surface;
	unsigned char *cairo_surface_data;
#endif
	list<string> lines;
	bool update_required;
	char prefix_key;
};

#include <libcgl/mm.h>
define_mm(console, consoles, console_ref);
#include "console.xx"

static void build_shader(console *cons);
interaction_mode *make_console_interaction_mode(console_ref ref);

console_ref make_console(const char *name, int screen_w, int screen_h, int height) {
	console_ref ref = allocate_console_ref();
	struct console *console = consoles+ref.id;

	console->name = strdup(name);
	console->screen_w = screen_w;
	console->screen_h = screen_h;
	console->height = height;
	tex_params_t p = default_fbo_tex_params();
	console->tex = make_empty_texture((string("console/")+name).c_str(), screen_w, height, GL_TEXTURE_2D, GL_RGBA8, GL_UNSIGNED_BYTE, GL_RGBA, &p);
	console->mesh = make_quad((string("console/")+name+"/quad").c_str(), 0);
	build_shader(console);
	new (&console->lines) list<string>();
	console->lines.push_back("");
	console->update_required = true;

#if LIBCGLS_HAVE_LIBCAIRO == 1
	console->cairo_surface = 0;
	console->cairo_surface_data = 0;
	console->cairo = create_cairo_context(screen_w, height, 4, &console->cairo_surface, &console->cairo_surface_data);
#else
	cerr << "! ! ! You are trying to create the console '" << name << "' but cairo support was not compiled in." << endl;
	cerr << "! ! ! Creating a dummy console." << endl;
#endif

	console->prefix_key = ':';

	push_interaction_mode(make_console_interaction_mode(ref));
	return ref;
}

static const char* console_vertex_shader() {
	return
		shader{
			#version 430 core
			in vec3 in_pos;
			layout(location=0) uniform float height_scale;
			out vec2 tc;
			void main() {
				tc = vec2(in_pos.x, in_pos.y);
				gl_Position = vec4(tc.x * 2 - 1, tc.y * height_scale * 2 - 1, -.8, 1);
				tc.y = 1.0 - tc.y;
			}
		}shader;
}

static const char* console_fragment_shader() {
	return
		shader{
			#version 430 core
			in vec2 tc;
			layout(location=1) uniform sampler2D tex;
			out vec4 out_col;
			void main() {
				out_col = vec4(texture(tex, tc).rgb, 1);
			}
		}shader;
}

static void build_shader(console *cons) {
	// why do i use stock-shader stuff here?
	struct stockshader_fragments ssf;
	init_stockshader_fragments(&ssf);
	stockshader_add_vsource(&ssf, console_vertex_shader());
	stockshader_add_fsource(&ssf, console_fragment_shader());
	stockshader_add_input(&ssf, "in_pos");
	cons->shader = make_shader("console-shader", 1);
	populate_shader_with_fragments(cons->shader, &ssf);
	compile_and_link_shader_showing_log_on_error(cons->shader);
	free_stockshader_fragments(&ssf);
}

static void update_console(console *c);

void render_console(console_ref ref) {
	struct console *console = consoles + ref.id;
	if (console->update_required) {
		update_console(console);
		console->update_required = false;
	}
	bind_mesh_to_gl(console->mesh);
	bind_shader(console->shader);
	glUniform1f(0, console->height / (float)console->screen_h);
	bind_texture(console->tex, 0);
	glUniform1i(1, 0);
	draw_mesh(console->mesh);
	unbind_texture(console->tex);
	unbind_shader(console->shader);
	unbind_mesh_from_gl(console->mesh);
}

void evaluate_console_command(console_ref ref) {
	struct console *console = consoles + ref.id;
	printf("eval '%s'\n", console->lines.back().c_str());
}

void console_add_char(console_ref ref, unsigned char c) {
	struct console *console = consoles + ref.id;
	if (c == 13) {
		evaluate_console_command(ref);
		console->lines.push_back("");
	}
	if (isprint(c))
		console->lines.back() += c;
	console->update_required = true;
}

#include <cairo/cairo.h>

#if LIBCGLS_HAVE_LIBCAIRO == 1

static void update_console(console *c) {
	cairo_t *cr = c->cairo;
	cairo_set_source_rgb(cr, 0, 0, 0);
	cairo_paint(cr);
	cairo_move_to(cr, 5, 14);
	cairo_set_font_size(cr, 14);
	cairo_select_font_face(cr, "DejaVu Serif", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
	cairo_set_source_rgb(cr, 1, 1, 1);
	cairo_show_text(cr, c->lines.back().c_str());
	cairo_surface_write_to_png(c->cairo_surface, "cai.png");
	bind_texture(c->tex, 0);
	unsigned char *data = cairo_image_surface_get_data(c->cairo_surface);
	glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, c->screen_w, c->height, GL_RGBA, GL_UNSIGNED_BYTE, data);
	unbind_texture(c->tex);
}

static cairo_t* create_cairo_context(int width, int height, int channels, cairo_surface_t **surf, unsigned char **buffer) {
	cairo_t *cr;

	/* create cairo-surface/context to act as OpenGL-texture source */
	*buffer = (unsigned char*)calloc(channels * width * height, sizeof(unsigned char));
	if (!*buffer) {
		printf("create_cairo_context() - Couldn't allocate surface-buffer\n");
		return 0;
	}

	*surf = cairo_image_surface_create_for_data(*buffer, CAIRO_FORMAT_ARGB32, width, height, channels * width);
	if (cairo_surface_status(*surf) != CAIRO_STATUS_SUCCESS) {
		free(*buffer);
		printf("create_cairo_context() - Couldn't create surface\n");
		return 0;
	}

	cr = cairo_create(*surf);
	if (cairo_status(cr) != CAIRO_STATUS_SUCCESS) {
		free(*buffer);
		printf("create_cairo_context() - Couldn't create context\n");
		return 0;
	}
	
	cairo_set_operator(cr, CAIRO_OPERATOR_OVER);
	cairo_set_source_rgb(cr, 0, 0, 0);
	cairo_paint(cr);
	return cr;
}

#else

static void update_console(console *c) {
}

#endif


// interaction

struct console_interaction_aux {
	console_ref console;
};

static void interaction_console_keyhandler(interaction_mode *mode, unsigned char key, int x, int y) {
	if (key == 27) {
		change_fallback_keyhandler_for_mode(mode, 0);
		return;
	}
	if (mode->type != cgls_interaction_console)
		return;
	console_interaction_aux *aux = (console_interaction_aux*)mode->aux;
	console_add_char(aux->console, key);
	if (key == 13)
		change_fallback_keyhandler_for_mode(mode, 0);
}

static void interaction_console_trigger(interaction_mode *mode, int x, int y) {
	change_fallback_keyhandler_for_mode(mode, interaction_console_keyhandler);
	console_interaction_aux *aux = (console_interaction_aux*)mode->aux;
	struct console *console = consoles + aux->console.id;
	console_add_char(aux->console, console->prefix_key);
}

interaction_mode *make_console_interaction_mode(console_ref ref) {
	struct console *console = consoles+ref.id;
	interaction_mode *mode = make_interaction_mode((string("interaction for console ")+console->name).c_str());
	mode->type = cgls_interaction_console;
	mode->aux = malloc(sizeof(console_interaction_aux));
	((console_interaction_aux*)(mode->aux))->console = ref;
	add_function_key_to_mode(mode, console->prefix_key, cgls_interaction_no_modifier, interaction_console_trigger);

	return mode;
}


