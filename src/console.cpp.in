#line 2 "console.cpp.in"
#include "console.h"
#include <libguile.h>

/*
 * 	NOTE: the cpp file is autogenerated from the cpp.in file!
 */

#include <libcgl/texture.h>
#include <libcgl/shader.h>
#include <libcgl/prepared.h>

#include "stock-shader.h"
#include "interaction.h"

#include <stdlib.h>
#include <string.h>
#include <string>
#include <iostream>
#include <list>
#include <vector>

#include "cgls-config.h"

#if LIBCGLS_HAVE_LIBCAIRO == 1
#include <cairo/cairo.h>
static cairo_t* create_cairo_context(int width, int height, int channels, cairo_surface_t** surf, unsigned char** buffer);
#endif


using namespace std;

// 
// basic console
// 


struct console {
	char *name;
	texture_ref tex;
	int screen_w, screen_h;
	int height;
	shader_ref shader;
	mesh_ref mesh;
#if LIBCGLS_HAVE_LIBCAIRO == 1
	cairo_t *cairo;
	cairo_surface_t *cairo_surface;
	unsigned char *cairo_surface_data;
#endif
	list<string> lines;
	bool update_required;
	bool visible;
	char prefix_key;
	int font_size;
	console_command_handler_t command_handler;
	interaction_mode *interaction;
	unsigned int aux_type;
	void *aux;
};

#include <libcgl/mm.h>
define_mm(console, consoles, console_ref);
#include "console.xx"

static void build_shader(console *cons);
interaction_mode *make_console_interaction_mode(console_ref ref);

/*! \brief create a new on-screen console.
 * 	\note we push the console interaction mode. if this is not what you want, just pop it off the stack afterwards, and reinsert later using \ref console_interaction_mode.
 */
console_ref make_console(const char *name, int screen_w, int screen_h, int lines) {
	console_ref ref = allocate_console_ref();
	struct console *console = consoles+ref.id;

	console->name = strdup(name);
	console->screen_w = screen_w;
	console->screen_h = screen_h;
	console->font_size = 14;
	console->height = console->font_size+4;
	tex_params_t p = default_fbo_tex_params();
	console->tex = make_empty_texture((string("console/")+name).c_str(), screen_w, console->height, GL_TEXTURE_2D, GL_RGBA8, GL_UNSIGNED_BYTE, GL_RGBA, &p);
	console->mesh = make_quad((string("console/")+name+"/quad").c_str(), 0);
	build_shader(console);
	new (&console->lines) list<string>();
	console->lines.push_back("");
	console->update_required = true;
	console->visible = false;
	console->command_handler = 0;
	console->aux = 0;
	console->aux_type = 0;

#if LIBCGLS_HAVE_LIBCAIRO == 1
	console->cairo_surface = 0;
	console->cairo_surface_data = 0;
	console->cairo = create_cairo_context(screen_w, console->height, 4, &console->cairo_surface, &console->cairo_surface_data);
#else
	cerr << "! ! ! You are trying to create the console '" << name << "' but cairo support was not compiled in." << endl;
	cerr << "! ! ! Creating a dummy console." << endl;
#endif

	console->prefix_key = ':';

	console->interaction = make_console_interaction_mode(ref);
	push_interaction_mode(console->interaction);
	return ref;
}

console_ref find_console(const char *name) {
	console_ref ref = { -1 };
	if (strlen(name) == 0) return ref;
    for (int i = 0; i < next_console_index; ++i) {
        if (strcmp(consoles[i].name, name) == 0) {
			ref.id = i;
			return ref;
		}
	}
	return ref;
}

interaction_mode* console_interaction_mode(console_ref ref) {
	return consoles[ref.id].interaction;
}

static const char* console_vertex_shader() {
	return
		shader{
			#version 430 core
			in vec3 in_pos;
			layout(location=0) uniform float height_scale;
			out vec2 tc;
			void main() {
				tc = vec2(in_pos.x, in_pos.y);
				gl_Position = vec4(tc.x * 2 - 1, tc.y * height_scale * 2 - 1, -.8, 1);
				tc.y = 1.0 - tc.y;
			}
		}shader;
}

static const char* console_fragment_shader() {
	return
		shader{
			#version 430 core
			in vec2 tc;
			layout(location=1) uniform sampler2D tex;
			out vec4 out_col;
			void main() {
				out_col = vec4(texture(tex, tc).rgb, 1);
			}
		}shader;
}

static void build_shader(console *cons) {
	// why do i use stock-shader stuff here?
	struct stockshader_fragments ssf;
	init_stockshader_fragments(&ssf);
	stockshader_add_vsource(&ssf, console_vertex_shader());
	stockshader_add_fsource(&ssf, console_fragment_shader());
	stockshader_add_input(&ssf, "in_pos");
	cons->shader = make_shader("console-shader", 1);
	populate_shader_with_fragments(cons->shader, &ssf);
	compile_and_link_shader_showing_log_on_error(cons->shader);
	free_stockshader_fragments(&ssf);
}

static void update_console(console *c);

void render_console(console_ref ref) {
	struct console *console = consoles + ref.id;
	if (!console->visible)
		return;
	if (console->update_required) {
		update_console(console);
		console->update_required = false;
	}
	glDisable(GL_DEPTH_TEST);
	bind_mesh_to_gl(console->mesh);
	bind_shader(console->shader);
	glUniform1f(0, console->height / (float)console->screen_h);
	bind_texture(console->tex, 0);
	glUniform1i(1, 0);
	draw_mesh(console->mesh);
	unbind_texture(console->tex);
	unbind_shader(console->shader);
	unbind_mesh_from_gl(console->mesh);
	glEnable(GL_DEPTH_TEST);
}

bool evaluate_console_command(console_ref ref) {
	struct console *console = consoles + ref.id;
	char *response = 0;
	if (console->command_handler) {
		response = console->command_handler(ref, console->lines.back().c_str());
	}
	else
		response = strdup("no command handler attached to this console!");
	if (response)
		console->lines.push_back(response);
	else {
		console->lines.push_back("");
		console->visible = false;
	}
	console->update_required = true;
	free(response);
	return response != 0;
}

void console_add_char(console_ref ref, unsigned char c) {
	struct console *console = consoles + ref.id;
	if (isprint(c))
		console->lines.back() += c;
	else if (c == '\b' && console->lines.back().length() > 1)
		console->lines.back() = console->lines.back().substr(0, console->lines.back().length()-1);
	console->update_required = true;
}

#include <cairo/cairo.h>

#if LIBCGLS_HAVE_LIBCAIRO == 1

static void update_console(console *c) {
	cairo_t *cr = c->cairo;
	cairo_set_source_rgb(cr, 0, 0, 0);
	cairo_paint(cr);
	cairo_move_to(cr, 5, c->font_size);
	cairo_set_font_size(cr, c->font_size);
	cairo_select_font_face(cr, "DejaVu Serif", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
	cairo_set_source_rgb(cr, 1, 1, 1);
	cairo_show_text(cr, c->lines.back().c_str());
	cairo_surface_write_to_png(c->cairo_surface, "cai.png");
	bind_texture(c->tex, 0);
	unsigned char *data = cairo_image_surface_get_data(c->cairo_surface);
	glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, c->screen_w, c->height, GL_RGBA, GL_UNSIGNED_BYTE, data);
	unbind_texture(c->tex);
}

static cairo_t* create_cairo_context(int width, int height, int channels, cairo_surface_t **surf, unsigned char **buffer) {
	cairo_t *cr;

	/* create cairo-surface/context to act as OpenGL-texture source */
	*buffer = (unsigned char*)calloc(channels * width * height, sizeof(unsigned char));
	if (!*buffer) {
		printf("create_cairo_context() - Couldn't allocate surface-buffer\n");
		return 0;
	}

	*surf = cairo_image_surface_create_for_data(*buffer, CAIRO_FORMAT_ARGB32, width, height, channels * width);
	if (cairo_surface_status(*surf) != CAIRO_STATUS_SUCCESS) {
		free(*buffer);
		printf("create_cairo_context() - Couldn't create surface\n");
		return 0;
	}

	cr = cairo_create(*surf);
	if (cairo_status(cr) != CAIRO_STATUS_SUCCESS) {
		free(*buffer);
		printf("create_cairo_context() - Couldn't create context\n");
		return 0;
	}
	
	cairo_set_operator(cr, CAIRO_OPERATOR_OVER);
	cairo_set_source_rgb(cr, 0, 0, 0);
	cairo_paint(cr);
	return cr;
}

#else

static void update_console(console *c) {
}

#endif

// 
// interaction
// 

struct console_interaction_aux {
	console_ref console;
};

static void interaction_console_clear_response(interaction_mode *mode, int x, int y);
static void interaction_console_trigger(interaction_mode *mode, int x, int y);

static void interaction_console_clear_response_prefix(interaction_mode *mode, int x, int y) {
	interaction_console_clear_response(mode, x, y);
	interaction_console_trigger(mode, x, y);
}

static void interaction_console_clear_response(interaction_mode *mode, int x, int y) {
	console_interaction_aux *aux = (console_interaction_aux*)mode->aux;
	struct console *console = consoles + aux->console.id;
	console->lines.push_back("");
	console->update_required = true;
	console->visible = false;
	add_function_key_to_mode(mode, 27, cgls_interaction_no_modifier, 0);
// 	add_function_key_to_mode(mode, console->prefix_key, cgls_interaction_no_modifier, 0);
	add_function_key_to_mode(mode, 13, cgls_interaction_no_modifier, 0);
}

static void interaction_console_keyhandler(interaction_mode *mode, unsigned char key, int x, int y) {
	if (key == 27) {
		change_fallback_keyhandler_for_mode(mode, 0);
		return;
	}
	if (mode->type != cgls_interaction_console)
		return;
	console_interaction_aux *aux = (console_interaction_aux*)mode->aux;
	if (key == 13) {
		change_fallback_keyhandler_for_mode(mode, 0);
		if (evaluate_console_command(aux->console))	{ // true if there is a response.
			add_function_key_to_mode(mode, 27, cgls_interaction_no_modifier, interaction_console_clear_response);
			add_function_key_to_mode(mode, 13, cgls_interaction_no_modifier, interaction_console_clear_response);
			struct console *console = consoles + aux->console.id;
			add_function_key_to_mode(mode, console->prefix_key, cgls_interaction_no_modifier, interaction_console_clear_response_prefix);
		}
	}
	else
		console_add_char(aux->console, key);
}

static void interaction_console_trigger(interaction_mode *mode, int x, int y) {
	change_fallback_keyhandler_for_mode(mode, interaction_console_keyhandler);
	console_interaction_aux *aux = (console_interaction_aux*)mode->aux;
	struct console *console = consoles + aux->console.id;
	console_add_char(aux->console, console->prefix_key);
	console->visible = true;
}

interaction_mode *make_console_interaction_mode(console_ref ref) {
	struct console *console = consoles+ref.id;
	interaction_mode *mode = make_interaction_mode((string("interaction for console ")+console->name).c_str());
	mode->type = cgls_interaction_console;
	mode->aux = malloc(sizeof(console_interaction_aux));
	((console_interaction_aux*)(mode->aux))->console = ref;
	add_function_key_to_mode(mode, console->prefix_key, cgls_interaction_no_modifier, interaction_console_trigger);

	return mode;
}

// 
// vi console
// 

struct vi_command {
	const char *name;
	vi_command_t c;
	SCM scm;
};

define_slist(vi_commands, vi_command command);

struct vi_console {
	vi_commands *commands;
};

char* vi_command_handler(console_ref ref, const char *line) {
	struct console *console = consoles + ref.id;
	if (console->aux_type != console_t_vi || console->aux == 0)
		return strdup("something strange happend to this console, I expected it to be vi-style...");
	struct vi_console *vi_console = (struct vi_console*)console->aux;
	char *strtok_save = 0;
	char *base = strdup(line+1);
	char *curr = base, *tmp = base;
	std::vector<char*> tokens;
	while ((curr = strtok_r(tmp, "\t ", &strtok_save)) != 0) {
		tmp = 0;
		tokens.push_back(strdup(curr));
	}
	char *response = 0;
	bool found = false;
	if (tokens.size())
		for (vi_commands *run = vi_console->commands; run; run = run->next)
			if (strcmp(run->command.name, tokens[0]) == 0) {
				if (run->command.c)
					response = run->command.c(ref, tokens.size(), &tokens[0]);
				else {
					SCM l = SCM_EOL;
					for (int i = 0; i < tokens.size(); ++i)
						l = scm_cons(scm_from_locale_string(tokens[i]), l);
					l = scm_reverse(l);
					SCM r = scm_call_2(run->command.scm, scm_from_int(ref.id), l);
					response = scm_to_locale_string(r);
				}
				found = true;
				break;
			}
	if (!found)
		response = strdup("command not found.");
	for (int i = 0; i < tokens.size(); ++i)
		free(tokens[i]);
	free(base);
	return response;
}

//! replaces an old command of the same name.
static void insert_vi_command_into_chain(console_ref ref, vi_command cmd) {
	struct console *console = consoles + ref.id;
	if (console->aux_type != console_t_vi || console->aux == 0) {
		fprintf(stderr, "cannot insert vi command into non vi console.\n");
		return;
	}
	struct vi_console *vi_console = (struct vi_console*)console->aux;
	for (vi_commands *run = vi_console->commands; run; run = run->next)
		if (strcmp(run->command.name, cmd.name) == 0) {
			run->command.c = cmd.c;
			run->command.scm = cmd.scm;
			return;
		}
	vi_commands *newcmd = (vi_commands*)malloc(sizeof(vi_commands));
	newcmd->command = cmd;
	newcmd->next = vi_console->commands;
	vi_console->commands = newcmd;
}

//! duplicates the command name
void add_vi_console_command(console_ref ref, const char *name, vi_command_t handler) {
	vi_command cmd;
	cmd.name = strdup(name);
	cmd.c = handler;
	cmd.scm = 0;
	insert_vi_command_into_chain(ref, cmd);
}

//! duplicates the command name
void add_vi_console_command_scm(console_ref ref, const char *name, SCM handler) {
	vi_command cmd;
	cmd.name = strdup(name);
	cmd.scm = handler;
	cmd.c = 0;
	insert_vi_command_into_chain(ref, cmd);
}

static char* vi_command_echo(console_ref ref, int argc, char **argv) {
	int len = 0;
	if (argc <= 2)
		return strdup("");
	for (int i = 1; i < argc; ++i)
		len += strlen(argv[i]);
	len += argc-2;
	char *response = (char*)malloc(len);
	*response = 0;
	for (int i = 1; i < argc; ++i) {
		strcat(response, argv[i]);
		if (i != argc-1)
			strcat(response, " ");
	}
	return response;
}

static char* vi_command_eval(console_ref ref, int argc, char **argv) {
#ifdef WITH_GUILE
	int len = 0;
	if (argc <= 2)
		return strdup("");
	for (int i = 1; i < argc; ++i)
		len += strlen(argv[i]);
	len += argc-2;
	char *cat = (char*)malloc(len);
	*cat = 0;
	for (int i = 1; i < argc; ++i) {
		strcat(cat, argv[i]);
		if (i != argc-1)
			strcat(cat, " ");
	}
	char *whole = strappend3("(format #f \"~a\" ", cat, ")");
	char *ret = scm_to_locale_string(scm_c_eval_string(whole));
	free(whole);
	free(cat);
	return ret;
#else
	return strdup("not supported");
#endif
}

static char* vi_command_default_help(console_ref ref, int argc, char **argv) {
	return strdup("this is just a lame ass vi-style console interaction -- don't expect too much ;)");
}

console_ref make_vi_console(const char *name, int screen_w, int screen_h) {
	console_ref ref = make_console(name, screen_w, screen_h, 1);
	struct console *console = consoles + ref.id;
	vi_console *vi = new vi_console;
	console->command_handler = vi_command_handler;
	console->aux = vi;
	console->aux_type = console_t_vi;
	vi->commands = 0;
	add_vi_console_command(ref, "echo", vi_command_echo);
	add_vi_console_command(ref, "eval", vi_command_eval);
	add_vi_console_command(ref, "help", vi_command_default_help);
	scm_c_eval_string("(define (vi-command-default-scm-help console args) (format #f \"this is also a really lame ass emacs-style console, you can register commands by supplying a guile/scheme procedure. Maybe you could be interested in the scheme console, too?\"))");
	add_vi_console_command_scm(ref, "help-scm", scm_c_eval_string("vi-command-default-scm-help"));
	return ref;
}

#ifdef WITH_GUILE

extern "C" {

SCM_DEFINE(s_find_console, "find-console", 1, 0, 0, (SCM name), "") {
    char *n = scm_to_locale_string(name);
    console_ref ref = find_console(n);
    free(n);
    return scm_from_int(ref.id);
}

SCM_DEFINE(s_add_console_cmd, "add-vi-console-command", 3, 0, 0, (SCM console, SCM name, SCM proc), "") {
	console_ref ref = { scm_to_int(console) };
    char *n = scm_to_locale_string(name);
	add_vi_console_command_scm(ref, n, proc);
	free(n);
	return SCM_BOOL_T;
}

void register_scheme_functions_for_console() {
#ifndef SCM_MAGIC_SNARFER
#include "console.x"
#endif
}

}

#endif

