#line 2 "stock-shader.c.in"

#include "stock-shader.h"
#include "material.h"

#include <libcgl/framebuffer.h>
#include <libcgl/prepared.h>

#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

void init_stockshader_fragments(struct stockshader_fragments *ssf) {
	ssf->inputs = ssf->vertex_sources = ssf->fragment_sources = ssf->uniforms = 0;
}

void free_stockshader_fragments(struct stockshader_fragments *ssf) {
	struct stockshader_stringlist *data[4] = { ssf->inputs, 
	                                           ssf->vertex_sources, 
									           ssf->fragment_sources, 
									           ssf->uniforms };
	for (int i = 0; i < 4; ++i)
		for (struct stockshader_stringlist *run = data[i]; run; ) {
			if (run->malloced)
				free(run->data);
			struct stockshader_stringlist *old = run;
			run = run->next;
			free(old);
		}
}

static void stringlist_pushback(struct stockshader_stringlist **list, const char *str) {
	struct stockshader_stringlist *new_entry = malloc(sizeof(struct stockshader_stringlist));
	new_entry->next = 0;
	new_entry->malloced = true;
	new_entry->data = strdup(str);
	if (*list == 0)
		*list = new_entry;
	else {
		struct stockshader_stringlist *run = *list;
		while (run->next)
			run = run->next;
		run->next = new_entry;
	}
}

static int stringlist_length(struct stockshader_stringlist *list) {
	int i = 0;
	while (list)
		i++, list = list->next;
	return i;
}

void stockshader_add_input(struct stockshader_fragments *ssf, const char *name)    { stringlist_pushback(&ssf->inputs, name); }
void stockshader_add_vsource(struct stockshader_fragments *ssf, const char *code)  { stringlist_pushback(&ssf->vertex_sources, code); };
void stockshader_add_fsource(struct stockshader_fragments *ssf, const char *code)  { stringlist_pushback(&ssf->fragment_sources, code); };
void stockshader_add_uniform(struct stockshader_fragments *ssf, const char *name)  { stringlist_pushback(&ssf->uniforms, name); };
int stockshader_inputs(struct stockshader_fragments *ssf)   { return stringlist_length(ssf->inputs); }
int stockshader_vsources(struct stockshader_fragments *ssf) { return stringlist_length(ssf->vertex_sources); }
int stockshader_fsources(struct stockshader_fragments *ssf) { return stringlist_length(ssf->fragment_sources); }
int stockshader_uniforms(struct stockshader_fragments *ssf) { return stringlist_length(ssf->uniforms); }

enum settings {
	modulate_texture_by_color = 01,
	ignore_ambient = 02,
};

enum settings settings = modulate_texture_by_color | ignore_ambient;

bool ign_amb() {
	return settings & ignore_ambient;
}

// %%%

const char* vertex_pos_norm_notex() {
	return
		shader{
			#version 420 core
			in vec3 in_pos;
			in vec3 in_norm;
	
			uniform mat4 proj;
			uniform mat4 view;
			uniform mat4 model;
			
			out vec4 pos_wc;
			out vec3 norm_wc;

			void main() {
				pos_wc = model * vec4(in_pos, 1.0);
				norm_wc = (model * vec4(in_norm,0.0)).xyz; // assuming model is not strange.
				gl_Position = proj * view * pos_wc;
			}
		}shader;
}

const char* vertex_pos_norm_tex() {
	return
		shader{
			#version 420 core
			in vec3 in_pos;
			in vec3 in_norm;
			in vec2 in_tc;
	
			uniform mat4 proj;
			uniform mat4 view;
			uniform mat4 model;
			
			out vec4 pos_wc;
			out vec3 norm_wc;
			out vec2 tc;

			void main() {
				pos_wc = model * vec4(in_pos, 1.0);
				norm_wc = (model * vec4(in_norm,0.0)).xyz; // assuming model is not strange.
				tc = in_tc;
				gl_Position = proj * view * pos_wc;
			}
		}shader;
}

const char* fragment_part_no_no_no_no(const char ***u) {
	static const char *uniforms[] = {
		"ambient_color",
		"diffuse_color",
		"specular_color",
		"shininess",
		0
	};
	*u = uniforms;
	return
		shader{
			#version 420 core
			uniform vec4 ambient_color;
			uniform vec4 diffuse_color;
			uniform vec4 specular_color;
			uniform float shininess;

			float mask() {
				return 1.0;
			}

			vec4 ambient() {
				return ambient_color;
			}

			vec4 diffuse() {
				return diffuse_color;
			}

			vec4 specular() {
				return specular_color;
			}
		}shader;
}

const char* fragment_part_no_diff_no_no(const char ***u) {
	static const char *uniforms[] = {
		"ambient_color",
		"diffuse_color",
		"specular_color",
		"shininess",
		"diffuse_tex",
		0
	};
	*u = uniforms;
	return
		shader{
			#version 420 core
			uniform vec4 ambient_color;
			uniform vec4 diffuse_color;
			uniform vec4 specular_color;
			uniform float shininess;
			uniform sampler2D diffuse_tex;
			in vec2 tc;

			float mask() {
				return 1.0;
			}

			vec4 ambient() {
				return ambient_color;
			}

			vec4 diffuse() {
				return diffuse_color * texture(diffuse_tex, tc);
			}

			vec4 specular() {
				return specular_color;
			}
		}shader;
}

const char* fragment_part_no_diff_no_mask(const char ***u) {
	static const char *uniforms[] = {
		"ambient_color",
		"diffuse_color",
		"specular_color",
		"shininess",
		"diffuse_tex",
		"mask_tex",
		0
	};
	*u = uniforms;
	return
		shader{
			#version 420 core
			uniform vec4 ambient_color;
			uniform vec4 diffuse_color;
			uniform vec4 specular_color;
			uniform float shininess;
			uniform sampler2D diffuse_tex;
			uniform sampler2D mask_tex;
			in vec2 tc;

			float mask() {
				return texture(mask_tex, tc).r;
			}

			vec4 ambient() {
				return ambient_color;
			}

			vec4 diffuse() {
				return diffuse_color * texture(diffuse_tex, tc);
			}

			vec4 specular() {
				return specular_color;
			}
		}shader;
}

const char* dummy_fragment_shader() {
	return
		shader{
			// looks like the driver is just pasting the src files together... m( #version 150 core
			in vec4 pos_wc;
			in vec3 norm_wc;

			vec4 ambient();
			vec4 diffuse();
			vec4 specular();
			float mask();

			out vec4 out_col;
			uniform mat4 view;

			float headmounted_spot(vec3 spot_dir, vec3 l) {
				float theta = acos(dot(spot_dir, -l));
				float spot_cutoff = 35.0 * 3.1415 / 180.0;
				float factor = 1.0 - smoothstep(spot_cutoff*.5, spot_cutoff, theta);
				return max(factor, 0.0);
			}

			void main() {
				if (mask() < 0.2)
					discard;
				vec3 n = normalize(mat3x3(transpose(inverse(view))) * norm_wc);
				vec4 pos_ec = view * pos_wc;
				vec3 l = -normalize(pos_ec.xyz);
				vec3 v = -normalize(pos_ec.xyz);
				float spot_factor = headmounted_spot(vec3(0,0,-1), l);
				
				float n_dot_l = max(dot(n, l), 0);
				out_col = vec4(diffuse().rgb * spot_factor * n_dot_l, 1.0);
				
				vec3 h = normalize(l+v);
				float i = pow(clamp(dot(h, n), 0, 1), shininess);

			}
		}shader;
}

const char* stock_gbuffer_creation_fragment_shader() {
	return
		shader{
			// looks like the driver is just pasting the src files together... m( #version 150 core
			in vec4 pos_wc;
			in vec3 norm_wc;

			vec4 ambient();
			vec4 diffuse();
			vec4 specular();
			float mask();

			out vec4 out_diff;
			out vec4 out_spec;
			out vec4 out_norm;
			out vec4 out_pos;
			uniform mat4 view;

			void main() {
				if (mask() < 0.2)
					discard;
				vec3 n = normalize(mat3x3(transpose(inverse(view))) * norm_wc);
				vec4 pos_ec = view * pos_wc;

                out_diff = diffuse();
                out_spec = vec4(specular().rgb, shininess);
                out_norm = vec4(n, 0);
                out_pos = pos_ec;
			}
		}shader;
}


const char* stock_gbuffer_using_vertex_shader() {
	return
		shader{
			#version 150 core
			in vec2 in_pos;
			in vec2 in_tc;
			out vec2 tc;
			void main() {
				tc = in_tc;
				gl_Position = vec4(in_pos, -0.8, 1.0);
			}
		}shader;
}

const char* stock_show_gbuffer_debug_shader() {
	return
		shader{
			#version 150 core
			uniform sampler2D gbuffer_diffuse;
			uniform sampler2D gbuffer_normal;
			uniform sampler2D gbuffer_depth;
			out vec4 out_col;
			in vec2 tc;
			void main() {
				vec2 tc2 = tc * 2.0;
				if (tc.x < 0.5 && tc.y >= 0.5)
					out_col = vec4(texture(gbuffer_diffuse, tc2 -vec2(0,1)).rgb, 1);
				else if (tc.x >= 0.5 && tc.y >= 0.5)
					out_col = vec4(texture(gbuffer_normal, tc2 - vec2(1,1)).rgb, 1);
				else if (tc.x < 0.5 && tc.y < 0.5)
					out_col = vec4(texture(gbuffer_depth, tc2).rgb, 1);
				else
				{
					if (length(texture(gbuffer_normal, tc2 - vec2(1,1)).rgb) < 0.1)
						out_col = vec4(1,0,0,1);
					else out_col = vec4(0,0,0,1);
				}
			}
		}shader;
}

/*! \defgroup deferred
 */

//! a very basic spotlight (which requires no further uniforms). \ingroup deferred
const char* stock_effect_headmounted_spot() {
	return
		shader{
			#version 150 core
			uniform sampler2D gbuffer_diffuse;
			uniform sampler2D gbuffer_specular;
			uniform sampler2D gbuffer_normal;
			uniform sampler2D gbuffer_position;
			uniform sampler2D gbuffer_depth;
			out vec4 out_col;
			in vec2 tc;
			
			float headmounted_spot(vec3 spot_dir, vec3 l) {
				float theta = acos(dot(spot_dir, -l));
				float spot_cutoff = 35.0 * 3.1415 / 180.0;
				float factor = 1.0 - smoothstep(spot_cutoff*.5, spot_cutoff, theta);
				return max(factor, 0.0);
			}

			void main() {
				vec3 pos_ec = texture(gbuffer_position, tc).xyz;
				vec3 n = texture(gbuffer_normal, tc).xyz;

				vec3 l = -normalize(pos_ec.xyz);
				vec3 v = -normalize(pos_ec.xyz);
				float spot_factor = headmounted_spot(vec3(0,0,-1), l);
			
				float n_dot_l = max(dot(n, l), 0);
				vec4 diffuse = texture(gbuffer_diffuse, tc);
				out_col = vec4(diffuse.rgb * spot_factor * n_dot_l, 1.0);
				
				vec4 specular = texture(gbuffer_specular, tc);
				vec3 h = normalize(l+v);
				float i = pow(clamp(dot(h, n), 0, 1), specular.a);
				out_col += vec4(specular.rgb * spot_factor * i, 0);
			}
		}shader;
}

/*! apply hemispherical lighting. 
 *  you'll have to supply the uniforms 
 *  \param hemi_dir hemisphere direction to pole -- in eye space!
 *  \param hemi_col color of the light.
 *  by your own uniform handler.
 *
 *  \note you also have to add then to the resulting shader.
 *  \ingroup deferred
 */
const char* stock_effect_hemisphere_lighting() {
	return
		shader{
			#version 150 core
			uniform sampler2D gbuffer_diffuse;
			uniform sampler2D gbuffer_normal;
            uniform vec3 hemi_dir;
            uniform vec3 hemi_col;
			out vec4 out_col;
			in vec2 tc;

			void main() {
				vec3 n = normalize(texture(gbuffer_normal, tc).xyz);
				vec4 diffuse = texture(gbuffer_diffuse, tc);

                float factor = max(0, 0.5*(1+dot(n, normalize(vec3(0,1,0)))));
//                 float factor = max(0, 0.5*(1+dot(n, normalize(hemi_dir))));
                out_col = vec4(diffuse.rgb * factor, 0.);
			}
		}shader;
}


void apply_to_bound_gbuffer(shader_ref shader) {
}

// %%%

void add_stock_vertex_shader(struct stockshader_fragments *ssf, bool use_normals, bool use_texcoords) {
	const char *src = 0;
	if      ( use_normals && !use_texcoords) src = vertex_pos_norm_notex();
	else if ( use_normals &&  use_texcoords) src = vertex_pos_norm_tex();

	stockshader_add_input(ssf, "in_pos");
	if (use_normals) stockshader_add_input(ssf, "in_norm");
	if (use_texcoords) stockshader_add_input(ssf, "in_tc");
	stockshader_add_uniform(ssf, "proj");
	stockshader_add_uniform(ssf, "view");
	stockshader_add_uniform(ssf, "model");
	stockshader_add_vsource(ssf, src);
}

void add_stock_fragment_shader_part(struct stockshader_fragments *ssf, bool use_normals, bool ambient_tex, bool diffuse_tex, bool specular_tex, bool mask_tex) {
	bool use_tc = false;
	if (ambient_tex || diffuse_tex || specular_tex || mask_tex)
		use_tc = true;
	if (ign_amb())
		ambient_tex = false;

	add_stock_vertex_shader(ssf, use_normals, use_tc);

	printf("making shader:   A:%d  D:%d  S:%d  M:%d\n", ambient_tex, diffuse_tex, specular_tex, mask_tex);

	const char *src = 0;
	const char **uniforms = 0;
	if      (  !ambient_tex  &&  !diffuse_tex  &&  !specular_tex  &&  !mask_tex)    src = fragment_part_no_no_no_no(&uniforms);
	else if (  !ambient_tex  &&   diffuse_tex  &&  !specular_tex  &&  !mask_tex)    src = fragment_part_no_diff_no_no(&uniforms);
	else if (  !ambient_tex  &&   diffuse_tex  &&  !specular_tex  &&   mask_tex)    src = fragment_part_no_diff_no_mask(&uniforms);
// 	else if (   ambient_tex  &&  !diffuse_tex  &&  !specular_tex  &&  !mask_tex)    src = fragment_part_no_no_no_no(&uniforms);
// 	else if (   ambient_tex  &&   diffuse_tex  &&  !specular_tex  &&  !mask_tex)    src = fragment_part_no_diff_no_no(&uniforms);
// 	else if (   ambient_tex  &&   diffuse_tex  &&  !specular_tex  &&   mask_tex)    src = fragment_part_no_diff_no_mask(&uniforms);
	else src = fragment_part_no_no_no_no(&uniforms);

	for (int i = 0; uniforms[i]; ++i)
		stockshader_add_uniform(ssf, uniforms[i]);
	stockshader_add_fsource(ssf, src);
}

/*! very basic extension to \ref compile_and_link_shader.
 * \attention does handle neither tesselation nor compute shaders, atm.
 */
bool compile_and_link_shader_showing_log_on_error(shader_ref shader) {
	if (!compile_and_link_shader(shader)) {
		fprintf(stderr, "SHADER ERROR\n");
		if (vertex_shader_info_log(shader))
			fprintf(stderr, "VERTEX-LOG:\n%s\n", vertex_shader_info_log(shader));
		if (fragment_shader_info_log(shader))
			fprintf(stderr, "FRAGMENT-LOG:\n%s\n", fragment_shader_info_log(shader));
		if (geometry_shader_info_log(shader))
			fprintf(stderr, "GEOMETRY-LOG:\n%s\n", geometry_shader_info_log(shader));
		if (shader_info_log(shader))
			fprintf(stderr, "PROGRAM-LOG:\n%s\n", shader_info_log(shader));
	}
}

//! generates the shader fragments for the stock shader as specified by the flags.
void stock_shader(struct stockshader_fragments *ssf, bool ambient_tex, bool diffuse_tex, bool specular_tex, bool mask_tex) {
	add_stock_fragment_shader_part(ssf, true, ambient_tex, diffuse_tex, specular_tex, mask_tex);

// 	stockshader_add_fsource(ssf, dummy_fragment_shader());
	stockshader_add_fsource(ssf, stock_gbuffer_creation_fragment_shader());
}

//! adds the accumulated data regarding the shader fragments to the given shader (which must at least exist, see \ref make_shader).
void populate_shader_with_fragments(shader_ref shader, struct stockshader_fragments *ssf) {
	int i = 0;
	for (struct stockshader_stringlist *run = ssf->inputs; run; run = run->next)
		add_shader_input(shader, run->data, i++);
	for (struct stockshader_stringlist *run = ssf->vertex_sources; run; run = run->next)
		add_vertex_source(shader, run->data);
	for (struct stockshader_stringlist *run = ssf->fragment_sources; run; run = run->next)
		add_fragment_source(shader, run->data);
	for (struct stockshader_stringlist *run = ssf->uniforms; run; run = run->next)
		add_shader_uniform(shader, run->data);
}

//! map texture "internal format" values to texture "type" values. \attention far from complete!  \ingroup deferred
static GLenum gl_type_of(GLenum x) {
	switch (x) {
	case GL_RGBA8:
		return GL_UNSIGNED_BYTE;

	case GL_DEPTH_COMPONENT16:
		return GL_UNSIGNED_SHORT;

	case GL_DEPTH_COMPONENT24:
	case GL_DEPTH_COMPONENT32:
		return GL_UNSIGNED_INT;

	default:
		return GL_FLOAT;
	}
}

/*! \brief create a default gbuffer usable with the stock shaders.
 *
 *  this might seem oddly placed in \ref stock-shader.c but it is specifically
 *  set up to work with the stock shaders provided by this file and with them
 *  constitutes some part of the ``default pipeline''.
 *
 *  the format parameters (except depth) *must* be some specific RGBA_ value.
 *  the respective types are determined based on this format (defaulting to
 *  float if you do something unanticipated).
 *
 *  \note if you don't need a specular buffer just pass GL_NONE.
 *  \ingroup deferred
 */
framebuffer_ref make_stock_deferred_buffer(const char *name, unsigned int width, unsigned int height, 
                                           GLenum diffuse_format, GLenum specular_format, GLenum normal_format, 
                                           GLenum position_format, GLenum depth_format) {
	GLenum diffuse_type  = gl_type_of(diffuse_format),
	       specular_type = gl_type_of(specular_format),
	       normal_type   = gl_type_of(normal_format),
	       position_type = gl_type_of(position_format),
	       depth_type    = gl_type_of(depth_format);
	
	char *diffuse_name  = strappend3(name, "/", "diffuse"),
	     *specular_name = strappend3(name, "/", "specular"),
		 *normal_name   = strappend3(name, "/", "normal"),
		 *position_name = strappend3(name, "/", "position"),
		 *depth_name    = strappend3(name, "/", "depth");

	framebuffer_ref fbo = make_framebuffer(name, width, height);
	tex_params_t param = default_fbo_tex_params();
	param.min = param.mag = GL_NEAREST;
	texture_ref diffuse_tex  = make_empty_texture(diffuse_name,  width, height, GL_TEXTURE_2D, diffuse_format,  diffuse_type,  GL_RGBA, &param);
	texture_ref specular_tex = make_empty_texture(specular_name, width, height, GL_TEXTURE_2D, specular_format, specular_type, GL_RGBA, &param);
	texture_ref normal_tex   = make_empty_texture(normal_name,   width, height, GL_TEXTURE_2D, normal_format,   normal_type,   GL_RGBA, &param);
	texture_ref position_tex = make_empty_texture(position_name, width, height, GL_TEXTURE_2D, position_format, position_type, GL_RGBA, &param);
	texture_ref depth_tex    = make_empty_texture(depth_name,    width, height, GL_TEXTURE_2D, depth_format,    depth_type,    GL_DEPTH_COMPONENT, &param);

	bind_framebuffer(fbo);
	bind_texture(diffuse_tex,  0); attach_texture_as_colorbuffer(fbo, "diffuse",  diffuse_tex);
	bind_texture(specular_tex, 1); attach_texture_as_colorbuffer(fbo, "specular", specular_tex);
	bind_texture(normal_tex,   2); attach_texture_as_colorbuffer(fbo, "normal",   normal_tex);
	bind_texture(position_tex, 3); attach_texture_as_colorbuffer(fbo, "position", position_tex);
	bind_texture(depth_tex,    4); attach_texture_as_depthbuffer(fbo, "depth",    depth_tex);
	check_framebuffer_setup(fbo);
	unbind_framebuffer(fbo);
	unbind_texture(diffuse_tex);
	unbind_texture(specular_tex);
	unbind_texture(normal_tex);
	unbind_texture(position_tex);
	unbind_texture(depth_tex);

	free(diffuse_name);
	free(specular_name);
	free(normal_name);
	free(position_name);
	free(depth_name);

	return fbo;
}

/*! \brief create a default gbuffer drawelement (screen aligned quad with texcoords) with appropriate material and shader setup.
 *
 *  \param effect_name will be used as name for the drawelement, the material and the shader. so take care.
 *  \param fragment_source if this is 0 we'll use the default debugging shader.
 *
 *  you can add further uniforms to the resulting drawelement's shader.
 *  \ingroup deferred
 */
drawelement_ref make_stock_gbuffer_default_drawelement(framebuffer_ref fbo, const char *effect_name, const char *fragment_source) {
	mesh_ref mesh = make_quad_with_tc(effect_name, 0);
	vec4f c = { .8, .8, .8, 1.0 };
	material_ref mat = make_material(effect_name, &c, &c, &c);
	const char *name = framebuffer_name(fbo);
	char *diffuse_name  = strappend3(name, "/", "diffuse"),
	     *specular_name = strappend3(name, "/", "specular"),
		 *normal_name   = strappend3(name, "/", "normal"),
		 *position_name = strappend3(name, "/", "position"),
		 *depth_name    = strappend3(name, "/", "depth");
	material_add_texture_as(mat, find_texture(diffuse_name),  "gbuffer_diffuse");
	material_add_texture_as(mat, find_texture(specular_name), "gbuffer_specular");
	material_add_texture_as(mat, find_texture(normal_name),   "gbuffer_normal");
	material_add_texture_as(mat, find_texture(position_name), "gbuffer_position");
	material_add_texture_as(mat, find_texture(depth_name),    "gbuffer_depth");
	
	shader_ref shader = make_shader(effect_name, 2, 5);
	struct stockshader_fragments ssf;
	init_stockshader_fragments(&ssf);
	stockshader_add_input(&ssf, "in_pos");
	stockshader_add_input(&ssf, "in_tc");
	stockshader_add_uniform(&ssf, "gbuffer_diffuse");
	stockshader_add_uniform(&ssf, "gbuffer_specular");
	stockshader_add_uniform(&ssf, "gbuffer_normal");
	stockshader_add_uniform(&ssf, "gbuffer_position");
	stockshader_add_uniform(&ssf, "gbuffer_depth");
	stockshader_add_vsource(&ssf, stock_gbuffer_using_vertex_shader());
	if (!fragment_source)
		fragment_source = stock_show_gbuffer_debug_shader();
	stockshader_add_fsource(&ssf, fragment_source);

	populate_shader_with_fragments(shader, &ssf);
	compile_and_link_shader_showing_log_on_error(shader);
	free_stockshader_fragments(&ssf);

	drawelement_ref de = make_drawelement("gbuffer drawelement", mesh, shader, mat);
	prepend_drawelement_uniform_handler(de, (uniform_setter_t)default_material_uniform_handler);	// this is why we did a complete material setup.
	
	free(diffuse_name);
	free(specular_name);
	free(normal_name);
	free(position_name);
	free(depth_name);

	return de;
}
	
