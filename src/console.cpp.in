#line 2 "console.cpp.in"
#include "console.h"
#include <libguile.h>

/*
 * 	NOTE: the cpp file is autogenerated from the cpp.in file!
 */

#include <libcgl/texture.h>
#include <libcgl/shader.h>
#include <libcgl/prepared.h>

#include "stock-shader.h"
#include "interaction.h"

#include <stdlib.h>
#include <string.h>
#include <string>
#include <iostream>
#include <list>
#include <vector>

#include "cgls-config.h"

#if LIBCGLS_HAVE_LIBCAIRO == 1
#include <cairo/cairo.h>
static cairo_t* create_cairo_context(int width, int height, int channels, cairo_surface_t** surf, unsigned char** buffer);
#endif


using namespace std;

// 
// basic console
// 


struct console {
	char *name;
	texture_ref tex;
	int screen_w, screen_h;
	int height;
	shader_ref shader;
	mesh_ref mesh;
#if LIBCGLS_HAVE_LIBCAIRO == 1
	cairo_t *cairo;
	cairo_surface_t *cairo_surface;
	unsigned char *cairo_surface_data;
#endif
	list<string> lines;
	bool update_required;
	bool visible;
	char prefix_key;
	int font_size;
	console_command_handler_t command_handler;
	unsigned int aux_type;
	void *aux;
};

#include <libcgl/mm.h>
define_mm(console, consoles, console_ref);
#include "console.xx"

static void build_shader(console *cons);
interaction_mode *make_console_interaction_mode(console_ref ref);

console_ref make_console(const char *name, int screen_w, int screen_h, int lines) {
	console_ref ref = allocate_console_ref();
	struct console *console = consoles+ref.id;

	console->name = strdup(name);
	console->screen_w = screen_w;
	console->screen_h = screen_h;
	console->font_size = 14;
	console->height = console->font_size+4;
	tex_params_t p = default_fbo_tex_params();
	console->tex = make_empty_texture((string("console/")+name).c_str(), screen_w, console->height, GL_TEXTURE_2D, GL_RGBA8, GL_UNSIGNED_BYTE, GL_RGBA, &p);
	console->mesh = make_quad((string("console/")+name+"/quad").c_str(), 0);
	build_shader(console);
	new (&console->lines) list<string>();
	console->lines.push_back("");
	console->update_required = true;
	console->visible = false;
	console->command_handler = 0;
	console->aux = 0;
	console->aux_type = 0;

#if LIBCGLS_HAVE_LIBCAIRO == 1
	console->cairo_surface = 0;
	console->cairo_surface_data = 0;
	console->cairo = create_cairo_context(screen_w, console->height, 4, &console->cairo_surface, &console->cairo_surface_data);
#else
	cerr << "! ! ! You are trying to create the console '" << name << "' but cairo support was not compiled in." << endl;
	cerr << "! ! ! Creating a dummy console." << endl;
#endif

	console->prefix_key = ':';

	push_interaction_mode(make_console_interaction_mode(ref));
	return ref;
}

static const char* console_vertex_shader() {
	return
		shader{
			#version 430 core
			in vec3 in_pos;
			layout(location=0) uniform float height_scale;
			out vec2 tc;
			void main() {
				tc = vec2(in_pos.x, in_pos.y);
				gl_Position = vec4(tc.x * 2 - 1, tc.y * height_scale * 2 - 1, -.8, 1);
				tc.y = 1.0 - tc.y;
			}
		}shader;
}

static const char* console_fragment_shader() {
	return
		shader{
			#version 430 core
			in vec2 tc;
			layout(location=1) uniform sampler2D tex;
			out vec4 out_col;
			void main() {
				out_col = vec4(texture(tex, tc).rgb, 1);
			}
		}shader;
}

static void build_shader(console *cons) {
	// why do i use stock-shader stuff here?
	struct stockshader_fragments ssf;
	init_stockshader_fragments(&ssf);
	stockshader_add_vsource(&ssf, console_vertex_shader());
	stockshader_add_fsource(&ssf, console_fragment_shader());
	stockshader_add_input(&ssf, "in_pos");
	cons->shader = make_shader("console-shader", 1);
	populate_shader_with_fragments(cons->shader, &ssf);
	compile_and_link_shader_showing_log_on_error(cons->shader);
	free_stockshader_fragments(&ssf);
}

static void update_console(console *c);

void render_console(console_ref ref) {
	struct console *console = consoles + ref.id;
	if (!console->visible)
		return;
	if (console->update_required) {
		update_console(console);
		console->update_required = false;
	}
	glDisable(GL_DEPTH_TEST);
	bind_mesh_to_gl(console->mesh);
	bind_shader(console->shader);
	glUniform1f(0, console->height / (float)console->screen_h);
	bind_texture(console->tex, 0);
	glUniform1i(1, 0);
	draw_mesh(console->mesh);
	unbind_texture(console->tex);
	unbind_shader(console->shader);
	unbind_mesh_from_gl(console->mesh);
	glEnable(GL_DEPTH_TEST);
}

bool evaluate_console_command(console_ref ref) {
	struct console *console = consoles + ref.id;
	char *response = 0;
	if (console->command_handler) {
		response = console->command_handler(ref, console->lines.back().c_str());
	}
	else
		response = strdup("no command handler attached to this console!");
	if (response)
		console->lines.push_back(response);
	else {
		console->lines.push_back("");
		console->visible = false;
	}
	console->update_required = true;
	free(response);
	return response != 0;
}

void console_add_char(console_ref ref, unsigned char c) {
	struct console *console = consoles + ref.id;
	if (isprint(c))
		console->lines.back() += c;
	console->update_required = true;
}

#include <cairo/cairo.h>

#if LIBCGLS_HAVE_LIBCAIRO == 1

static void update_console(console *c) {
	cairo_t *cr = c->cairo;
	cairo_set_source_rgb(cr, 0, 0, 0);
	cairo_paint(cr);
	cairo_move_to(cr, 5, c->font_size);
	cairo_set_font_size(cr, c->font_size);
	cairo_select_font_face(cr, "DejaVu Serif", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
	cairo_set_source_rgb(cr, 1, 1, 1);
	cairo_show_text(cr, c->lines.back().c_str());
	cairo_surface_write_to_png(c->cairo_surface, "cai.png");
	bind_texture(c->tex, 0);
	unsigned char *data = cairo_image_surface_get_data(c->cairo_surface);
	glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, c->screen_w, c->height, GL_RGBA, GL_UNSIGNED_BYTE, data);
	unbind_texture(c->tex);
}

static cairo_t* create_cairo_context(int width, int height, int channels, cairo_surface_t **surf, unsigned char **buffer) {
	cairo_t *cr;

	/* create cairo-surface/context to act as OpenGL-texture source */
	*buffer = (unsigned char*)calloc(channels * width * height, sizeof(unsigned char));
	if (!*buffer) {
		printf("create_cairo_context() - Couldn't allocate surface-buffer\n");
		return 0;
	}

	*surf = cairo_image_surface_create_for_data(*buffer, CAIRO_FORMAT_ARGB32, width, height, channels * width);
	if (cairo_surface_status(*surf) != CAIRO_STATUS_SUCCESS) {
		free(*buffer);
		printf("create_cairo_context() - Couldn't create surface\n");
		return 0;
	}

	cr = cairo_create(*surf);
	if (cairo_status(cr) != CAIRO_STATUS_SUCCESS) {
		free(*buffer);
		printf("create_cairo_context() - Couldn't create context\n");
		return 0;
	}
	
	cairo_set_operator(cr, CAIRO_OPERATOR_OVER);
	cairo_set_source_rgb(cr, 0, 0, 0);
	cairo_paint(cr);
	return cr;
}

#else

static void update_console(console *c) {
}

#endif

// 
// interaction
// 

struct console_interaction_aux {
	console_ref console;
};

static void interaction_console_clear_response(interaction_mode *mode, int x, int y);
static void interaction_console_trigger(interaction_mode *mode, int x, int y);

static void interaction_console_clear_response_prefix(interaction_mode *mode, int x, int y) {
	interaction_console_clear_response(mode, x, y);
	interaction_console_trigger(mode, x, y);
}

static void interaction_console_clear_response(interaction_mode *mode, int x, int y) {
	console_interaction_aux *aux = (console_interaction_aux*)mode->aux;
	struct console *console = consoles + aux->console.id;
	console->lines.push_back("");
	console->update_required = true;
	console->visible = false;
	add_function_key_to_mode(mode, 27, cgls_interaction_no_modifier, 0);
	add_function_key_to_mode(mode, console->prefix_key, cgls_interaction_no_modifier, 0);
}

static void interaction_console_keyhandler(interaction_mode *mode, unsigned char key, int x, int y) {
	if (key == 27) {
		change_fallback_keyhandler_for_mode(mode, 0);
		return;
	}
	if (mode->type != cgls_interaction_console)
		return;
	console_interaction_aux *aux = (console_interaction_aux*)mode->aux;
	if (key == 13) {
		change_fallback_keyhandler_for_mode(mode, 0);
		if (evaluate_console_command(aux->console))	{ // true if there is a response.
			add_function_key_to_mode(mode, 27, cgls_interaction_no_modifier, interaction_console_clear_response);
			struct console *console = consoles + aux->console.id;
			add_function_key_to_mode(mode, console->prefix_key, cgls_interaction_no_modifier, interaction_console_clear_response_prefix);
		}
	}
	else
		console_add_char(aux->console, key);
}

static void interaction_console_trigger(interaction_mode *mode, int x, int y) {
	change_fallback_keyhandler_for_mode(mode, interaction_console_keyhandler);
	console_interaction_aux *aux = (console_interaction_aux*)mode->aux;
	struct console *console = consoles + aux->console.id;
	console_add_char(aux->console, console->prefix_key);
	console->visible = true;
}

interaction_mode *make_console_interaction_mode(console_ref ref) {
	struct console *console = consoles+ref.id;
	interaction_mode *mode = make_interaction_mode((string("interaction for console ")+console->name).c_str());
	mode->type = cgls_interaction_console;
	mode->aux = malloc(sizeof(console_interaction_aux));
	((console_interaction_aux*)(mode->aux))->console = ref;
	add_function_key_to_mode(mode, console->prefix_key, cgls_interaction_no_modifier, interaction_console_trigger);

	return mode;
}

// 
// vi console
// 

struct vi_command {
	const char *name;
	vi_command_t c;
	SCM scm;
};

define_slist(vi_commands, vi_command command);

struct vi_console {
	vi_commands commands;
};

char* vi_command_handler(console_ref ref, const char *line) {
	struct console *console = consoles + ref.id;
	if (console->aux_type != console_t_vi || console->aux == 0)
		return strdup("something strange happend to this console, I expected it to be vi-style...");
	return strdup("vi handler");
}

void add_vi_console_command(console_ref ref, const char *name, vi_command_t handler) {
}

void add_vi_console_command_scm(console_ref ref, const char *name, SCM handler) {
}

console_ref make_vi_console(const char *name, int screen_w, int screen_h) {
	console_ref ref = make_console(name, screen_w, screen_h, 1);
	struct console *console = consoles + ref.id;
	console->command_handler = vi_command_handler;
	console->aux = new vi_console;
	console->aux_type = console_t_vi;
	return ref;
}

